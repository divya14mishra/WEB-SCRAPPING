Subject,Topic,Direction,Question,Option 1,Option 2,Option 3,Option 4,Option 5,Answer,Explanation
Cse Engineering,Language Fundamentals, ,"Which four options describe the correct default values for array elements of the types indicated?int -> 0String -> ""null""Dog -> nullchar -> '\u0000'float -> 0.0fboolean -> true","1, 2, 3, 4","1, 3, 4, 5","2, 4, 5, 6","3, 4, 5, 6", ,B," <p>(1), (3), (4), (5) are the correct statements.</p><p>(2) is wrong because the default value for a <i class=""java-code"">String</i> (and any other object reference) is <i class=""java-code"">null</i>, with no quotes.</p><p>(6) is wrong because the default value for boolean elements is <i class=""java-code"">false</i>.</p> "
Cse Engineering,Language Fundamentals, ,Which one of these lists contains only Java programming language keywords?,"class, if, void, long, Int, continue","goto, instanceof, native, finally, default, throws","try, virtual, throw, final, volatile, transient","strictfp, constant, super, implements, do","byte, break, assert, switch, include",B," <p>All the words in option B are among the 49 Java keywords. Although <i class=""java-code"">goto</i> reserved as a keyword in Java, <i class=""java-code"">goto</i> is not used and has no function.</p><p>Option A is wrong because the keyword for the primitive <i class=""java-code"">int</i> starts with a lowercase i.</p><p>Option C is wrong because ""<i class=""java-code"">virtual</i>"" is a keyword in C++, but not Java.</p><p>Option D is wrong because ""<i class=""java-code"">constant</i>"" is not a keyword. Constants in Java are marked <i class=""java-code"">static</i> and <i class=""java-code"">final</i>.</p><p>Option E is wrong because ""<i class=""java-code"">include</i>"" is a keyword in C, but not in  Java.</p> "
Cse Engineering,Language Fundamentals, ,"Which will legally declare, construct, and initialize an array?","int [] myList = {""1"", ""2"", ""3""},","int [] myList = (5, 8, 2),","int myList [] [] = {4,9,7,0},","int myList [] = {4, 3, 7},", ,D," <p>The only legal array declaration and assignment statement is Option D</p><p>Option A is wrong because it initializes an int array with <i class=""java-code"">String</i> literals.</p><p>Option B is wrong because it use something other than curly braces for the initialization.</p><p>Option C is wrong because it provides initial values for only one dimension, although the declared array is a two-dimensional array.</p> "
Cse Engineering,Language Fundamentals, ,Which is a reserved word in the Java programming language?,method,native,subclasses,reference,array,B," <p>The word ""<i class=""java-code"">native</i>"" is a valid keyword, used to modify a method declaration.</p><p>Option A, D and E are not keywords. Option C is wrong because the keyword for subclassing in Java is extends, not 'subclasses'.</p> "
Cse Engineering,Language Fundamentals, ,Which is a valid keyword in java?,interface,string,Float,unsigned, ,A," <p><i class=""java-code"">interface</i> is a valid keyword.</p><p>Option B is wrong because although ""<i class=""java-code"">String</i>"" is a class type in Java, ""<i class=""java-code"">string</i>"" is not a keyword.</p><p>Option C is wrong because ""<i class=""java-code"">Float</i>"" is a class type. The keyword for the Java primitive is <i class=""java-code"">float</i>.</p><p>Option D is wrong because ""<i class=""java-code"">unsigned</i>"" is a keyword in C/C++ but not in Java.</p> "
Cse Engineering,Language Fundamentals, ,"Which three are legal array declarations?int [] myScores [],char [] myChars,int [6] myScores,Dog myDogs [],Dog myDogs [7],","1, 2, 4","2, 4, 5","2, 3, 4",All are correct., ,A," <p>(1), (2), and (4) are legal array declarations. With an array declaration, you can place the brackets to the right or left of the identifier. Option A looks strange, but it's perfectly legal to split the brackets in a multidimensional array, and place them on both sides of the identifier. Although coding this way would only annoy your fellow programmers, for the exam, you need to know it's legal.</p><p>(3) and (5) are wrong because you can't declare an array with a size. The size is only needed when the array is actually instantiated (and the JVM needs to know how much space to allocate for the array, based on the type of array and the size).</p> "
Cse Engineering,Language Fundamentals, ,"public interface Foo {     int k = 4, /* Line 3 */}Which three piece of codes are equivalent to line 3?final int k = 4,public int k = 4,static int k = 4,abstract int k = 4,volatile int k = 4,protected int k = 4,","1, 2 and 3","2, 3 and 4","3, 4 and 5","4, 5 and 6", ,A," <p>(1), (2) and (3) are correct. Interfaces can have constants, which are always implicitly <i class=""java-code"">public</i>, <i class=""java-code"">static</i>, and <i class=""java-code"">final</i>. Interface constant declarations of <i class=""java-code"">public</i>, <i class=""java-code"">static</i>, and <i class=""java-code"">final</i> are optional in any combination. </p> "
Cse Engineering,Language Fundamentals, ,Which one of the following will declare an array and initialize it with five numbers?,"Array a = new Array(5),","int [] a = {23,22,21,20,19},","int a [] = new int[5],","int [5] array,", ,B," <p>Option B is the legal way to declare and initialize an <i class=""java-code"">array</i> with five elements.</p><p>Option A is wrong because it shows an example of instantiating a class named <i class=""java-code"">Array</i>, passing the integer value 5 to the object's constructor. If you don't see the brackets, you can be certain there is no actual array object! In other words, an <i class=""java-code"">Array</i> object (instance of class <i class=""java-code"">Array</i>) is not the same as an <i class=""java-code"">array</i> object.</p><p>Option C is wrong because it shows a legal <i class=""java-code"">array</i> declaration, but with no initialization.</p><p>Option D is wrong (and will not compile) because it declares an <i class=""java-code"">array</i> with a size. Arrays must never be given a size when declared.</p> "
Cse Engineering,Language Fundamentals, ,"Which three are valid declarations of a char?char c1 = 064770,char c2 = 'face',char c3 = 0xbeef,char c4 = \u0022,char c5 = '\iface',char c6 = '\uface',","1, 2, 4","1, 3, 6","3, 5",5 only, ,B," <p>(1), (3), and (6) are correct. <i class=""java-code"">char c1 = 064770,</i> is an octal representation of the integer value <i class=""java-code"">27128</i>, which is legal because it fits into an unsigned 16-bit integer. <i class=""java-code"">char c3 = 0xbeef,</i> is a hexadecimal representation of the integer value <i class=""java-code"">48879</i>, which fits into an unsigned 16-bit integer. <i class=""java-code"">char c6 = '\uface',</i> is a Unicode representation of a character.</p><p><i class=""java-code"">char c2 = 'face',</i> is wrong because you can't put more than one character in a char literal. The only other acceptable char literal that can go between single quotes is a Unicode value, and Unicode literals must always start with a <i class=""java-code"">'\u'</i>.</p><p><i class=""java-code"">char c4 = \u0022,</i> is wrong because the single quotes are missing.</p><p><i class=""java-code"">char c5 = '\iface',</i> is wrong because it appears to be a Unicode representation (notice the backslash), but starts with <i class=""java-code"">'\i'</i> rather than <i class=""java-code"">'\u'</i>.</p> "
Cse Engineering,Language Fundamentals, ,Which is the valid declarations within an interface definition?,"public double methoda(),","public final double methoda(),","static void methoda(double d1),","protected void methoda(double d1),", ,A," <p>Option A is correct. A <i class=""java-code"">public</i> access modifier is acceptable. The method prototypes in an interface are all abstract by virtue of their declaration, and should not be declared <i class=""java-code"">abstract</i>.</p><p>Option B is wrong. The <i class=""java-code"">final</i> modifier means that this method cannot be constructed in a subclass. A <i class=""java-code"">final</i> method cannot be <i class=""java-code"">abstract</i>. </p><p>Option C is wrong. <i class=""java-code"">static</i> is concerned with the class and not an instance. </p><p>Option D is wrong. <i class=""java-code"">protected</i> is not permitted when declaring a method of an interface. See information below. </p><p>Member declarations in an interface disallow the use of some declaration modifiers, you cannot use <i class=""java-code"">transient</i>, <i class=""java-code"">volatile</i>, or <i class=""java-code"">synchronized</i> in a member declaration in an interface. Also, you may not use the <i class=""java-code"">private</i> and <i class=""java-code"">protected</i> specifiers when declaring members of an interface.  </p> "
Cse Engineering,Language Fundamentals, ,Which one is a valid declaration of a boolean?,"boolean b1 = 0,","boolean b2 = 'false',","boolean b3 = false,","boolean b4 = Boolean.false(),","boolean b5 = no,",C," A boolean can only be assigned the literal <i class=""java-code"">true</i> or <i class=""java-code"">false</i>. "
Cse Engineering,Language Fundamentals, ,"Which three are valid declarations of a float?float f1 = -343,float f2 = 3.14,float f3 = 0x12345,float f4 = 42e7,float f5 = 2001.0D,float f6 = 2.81F,","1, 2, 4","2, 3, 5","1, 3, 6","2, 4, 6", ,C," <p>(1) and (3) are integer literals (32 bits), and integers can be legally assigned to <i class=""java-code"">float</i>s (also 32 bits). (6) is correct because (F) is appended to the literal, declaring it as a <i class=""java-code"">float</i> rather than a <i class=""java-code"">double</i> (the default for floating point literals).</p><p>(2), (4),and (5) are all doubles.</p> "
Cse Engineering,Language Fundamentals, ,Which is a valid declarations of a String?,"String s1 = null,","String s2 = 'null',","String s3 = (String) 'abc',","String s4 = (String) '\ufeed',", ,A," <p>Option A sets the String reference to <i class=""java-code"">null</i>.</p><p>Option B is wrong because <i class=""java-code"">null</i> cannot be in single quotes.</p><p>Option C is wrong because there are multiple characters between the single quotes ('abc').</p><p>Option D is wrong because you can't cast a <i class=""java-code"">char</i> (primitive) to a <i class=""java-code"">String</i> (object).</p> "
Cse Engineering,Language Fundamentals, ,What is the numerical range of a char?,-128 to 127,-(215) to (215) - 1,0 to 32767,0 to 65535, ,D," A <i class=""java-code"">char</i> is really a 16-bit integer behind the scenes, so it supports 2<sup>16</sup> (from 0 to 65535) values. "
Cse Engineering,Operators and Assignments, ,"What will be the output of the program?class PassA {    public static void main(String [] args)     {        PassA p = new PassA(),        p.start(),    }    void start()     {        long [] a1 = {3,4,5},        long [] a2 = fix(a1),        System.out.print(a1[0] + a1[1] + a1[2] + "" ""),        System.out.println(a2[0] + a2[1] + a2[2]),    }    long [] fix(long [] a3)     {        a3[1] = 7,        return a3,    }}",12 15,15 15,3 4 5 3 7 5,3 7 5 3 7 5, ,B," <p>Output: 15 15</p><p>The reference variables <i class=""java-code"">a1</i> and <i class=""java-code"">a3</i> refer to the same long array object. When the <i class=""java-code"">[1]</i> element is updated in the <i class=""java-code"">fix()</i> method, it is updating the array referred to by <i class=""java-code"">a1</i>. The reference variable <i class=""java-code"">a2</i> refers to the same array object.</p><p>So Output: 3+7+5+"" ""3+7+5</p><p>Output: 15 15 Because Numeric values will be added </p> "
Cse Engineering,Operators and Assignments, ,"What will be the output of the program?class Test {    public static void main(String [] args)     {        Test p = new Test(),        p.start(),    }    void start()     {        boolean b1 = false,        boolean b2 = fix(b1),        System.out.println(b1 + "" "" + b2),    }    boolean fix(boolean b1)     {        b1 = true,        return b1,    }}",true true,false true,true false,false false, ,B," <p>The boolean <i class=""java-code"">b1</i> in the <i class=""java-code"">fix()</i> method is a different boolean than the <i class=""java-code"">b1</i> in the <i class=""java-code"">start()</i> method. The <i class=""java-code"">b1</i> in the <i class=""java-code"">start()</i> method is not updated by the <i class=""java-code"">fix()</i> method.</p> "
Cse Engineering,Operators and Assignments, ,"What will be the output of the program?class PassS {    public static void main(String [] args)     {        PassS p = new PassS(),        p.start(),    }    void start()     {        String s1 = ""slip"",        String s2 = fix(s1),        System.out.println(s1 + "" "" + s2),    }    String fix(String s1)     {        s1 = s1 + ""stream"",        System.out.print(s1 + "" ""),        return ""stream"",    }}",slip stream,slipstream stream,stream slip stream,slipstream slip stream, ,D," <p>When the <i class=""java-code"">fix()</i> method is first entered, <i class=""java-code"">start()</i>'s s1 and <i class=""java-code"">fix()</i>'s <i class=""java-code"">s1</i> reference variables both refer to the same String object (with a value of ""slip""). <i class=""java-code"">Fix()</i>'s <i class=""java-code"">s1</i> is reassigned to a new object that is created when the concatenation occurs (this second String object has a value of ""slipstream""). When the program returns to <i class=""java-code"">start()</i>, another <i class=""java-code"">String</i> object is created, referred to by <i class=""java-code"">s2</i> and with a value of ""stream"".</p> "
Cse Engineering,Operators and Assignments, ,"What will be the output of the program?class BitShift {    public static void main(String [] args)     {        int x = 0x80000000,        System.out.print(x + "" and  ""),        x = x >>> 31,        System.out.println(x),    }}",-2147483648 and 1,0x80000000 and 0x00000001,-2147483648 and -1,1 and -2147483648, ,A," <p>Option A is correct. The <i class=""java-code"">&gt,&gt,&gt,</i> operator moves all bits to the right, zero filling the left bits. The bit transformation looks like this:</p><p>Before: <i class=""java-code"">1000 0000 0000 0000 0000 0000 0000 0000</i></p><p>After: <i class=""java-code"">0000 0000 0000 0000 0000 0000 0000 0001</i></p><p>Option C is incorrect because the <i class=""java-code"">&gt,&gt,&gt,</i> operator zero fills the left bits, which in this case changes the sign of <i class=""java-code"">x</i>, as shown.</p><p>Option B is incorrect because the output method <i class=""java-code"">print()</i> always displays integers in base 10.</p><p>Option D is incorrect because this is the reverse order of the two output numbers.</p> "
Cse Engineering,Operators and Assignments, ,"What will be the output of the program?class Equals {    public static void main(String [] args)     {        int x = 100,        double y = 100.1,        boolean b = (x = y), /* Line 7 */        System.out.println(b),    }}",TRUE,FALSE,Compilation fails,An exception is thrown at runtime, ,C," <p>The code will not compile because in line 7, the line will work only if we use <i class=""java-code"">(x==y)</i> in the line. The <i class=""java-code"">==</i> operator compares values to produce a boolean, whereas the <i class=""java-code"">=</i> operator assigns a value to variables.</p><p>Option A, B, and D are incorrect because the code does not get as far as compiling. If we corrected this code, the output would be false.</p> "
Cse Engineering,Operators and Assignments, ,"What will be the output of the program?class Test {    public static void main(String [] args)     {        int x=20,        String sup = (x < 15) ? ""small"" : (x < 22)? ""tiny"" : ""huge"",        System.out.println(sup),    }}",small,tiny,huge,Compilation fails, ,B," <p>This is an example of a nested ternary operator. The second evaluation <i class=""java-code"">(x &lt, 22)</i> is <i class=""java-code"">true</i>, so the ""<i class=""java-code"">tiny</i>"" value is assigned to <i class=""java-code"">sup</i>.</p> "
Cse Engineering,Operators and Assignments, ,"What will be the output of the program?class Test {    public static void main(String [] args)     {        int x= 0,        int y= 0,        for (int z = 0, z < 5, z++)         {            if (( ++x > 2 ) && (++y > 2))             {                x++,            }        }        System.out.println(x + "" "" + y),    }}",5 2,5 3,6 3,6 4, ,C," <p>In the first two iterations <i class=""java-code"">x</i> is incremented once and <i class=""java-code"">y</i> is not because of the short circuit <i class=""java-code"">&amp,&amp,</i> operator. In the third and forth iterations <i class=""java-code"">x</i> and <i class=""java-code"">y</i> are each incremented, and in the fifth iteration <i class=""java-code"">x</i> is doubly incremented and <i class=""java-code"">y</i> is incremented.</p> "
Cse Engineering,Operators and Assignments, ,"What will be the output of the program?class Test {    public static void main(String [] args)     {        int x= 0,        int y= 0,        for (int z = 0, z < 5, z++)         {            if (( ++x > 2 ) || (++y > 2))             {                x++,            }        }    System.out.println(x + "" "" + y),    }}",5 3,8 2,8 3,8 5, ,B," <p>The first two iterations of the <i class=""java-code"">for</i> loop both <i class=""java-code"">x</i> and <i class=""java-code"">y</i> are incremented. On the third iteration <i class=""java-code"">x</i> is incremented, and for the first time becomes greater than 2. The short circuit or operator <i class=""java-code"">||</i> keeps <i class=""java-code"">y</i> from ever being incremented again and <i class=""java-code"">x</i> is incremented twice on each of the last three iterations.</p> "
Cse Engineering,Operators and Assignments, ,"What will be the output of the program?class Bitwise {    public static void main(String [] args)     {        int x = 11 & 9,        int y = x ^ 3,        System.out.println( y | 12 ),    }}",0,7,8,14, ,D," <p>The <i class=""java-code"">&amp,</i> operator produces a 1 bit when both bits are 1. The result of the <i class=""java-code"">&amp,</i> operation is 9. The <i class=""java-code"">^</i> operator produces a 1 bit when exactly one bit is 1, the result of this operation is 10. The <i class=""java-code"">|</i> operator produces a 1 bit when at least one bit is 1, the result of this operation is 14.</p> "
Cse Engineering,Operators and Assignments, ,"What will be the output of the program?class SSBool {    public static void main(String [] args)     {        boolean b1 = true,        boolean b2 = false,        boolean b3 = true,        if ( b1 & b2 | b2 & b3 | b2 ) /* Line 8 */            System.out.print(""ok ""),        if ( b1 & b2 | b2 & b3 | b2 | b1 ) /*Line 10*/            System.out.println(""dokey""),    }}",ok,dokey,ok dokey,No output is produced,Compilation error,B," <p>The <i class=""java-code"">&amp,</i> operator has a higher precedence than the <i class=""java-code"">|</i> operator so that on line 8 <i class=""java-code"">b1</i> and <i class=""java-code"">b2</i> are evaluated together as are <i class=""java-code"">b2 &amp, b3</i>. The final b1 in line 10 is what causes that if test to be true. Hence it prints ""<i class=""java-code"">dokey</i>"".</p> "
Cse Engineering,Operators and Assignments, ,"What will be the output of the program?class SC2 {    public static void main(String [] args)     {        SC2 s = new SC2(),        s.start(),    }    void start()     {        int a = 3,        int b = 4,        System.out.print("" "" + 7 + 2 + "" ""),        System.out.print(a + b),        System.out.print("" "" + a + b + "" ""),        System.out.print(foo() + a + b + "" ""),        System.out.println(a + b + foo()),    }    String foo()     {        return ""foo"",    }}",9 7 7 foo 7 7foo,72 34 34 foo34 34foo,9 7 7 foo34 34foo,72 7 34 foo34 7foo, ,D," <p>Because all of these expressions use the <i class=""java-code"">+</i> operator, there is no precedence to worry about and all of the expressions will be evaluated from left to right. If either operand being evaluated is a String, the <i class=""java-code"">+</i> operator will concatenate the two operands, if both operands are numeric, the <i class=""java-code"">+</i> operator will add the two operands.</p> "
Cse Engineering,Operators and Assignments, ,"What will be the output of the program?class Test {    static int s,    public static void main(String [] args)     {        Test p = new Test(),        p.start(),        System.out.println(s),    }    void start()     {        int x = 7,        twice(x),        System.out.print(x + "" ""),    }    void twice(int x)     {        x = x*2,        s = x,    }}",7 7,7 14,14 0,14 14, ,B," <p>The <i class=""java-code"">int x</i> in the <i class=""java-code"">twice()</i> method is not the same <i class=""java-code"">int x</i> as in the <i class=""java-code"">start()</i> method. <i class=""java-code"">Start()</i>'s <i class=""java-code"">x</i> is not affected by the <i class=""java-code"">twice()</i> method. The instance variable <i class=""java-code"">s</i> is updated by <i class=""java-code"">twice()</i>'s <i class=""java-code"">x</i>, which is 14.</p> "
Cse Engineering,Operators and Assignments, ,"What will be the output of the program?class Two {    byte x,}class PassO {    public static void main(String [] args)     {        PassO p = new PassO(),        p.start(),    }    void start()     {        Two t = new Two(),        System.out.print(t.x + "" ""),        Two t2 = fix(t),        System.out.println(t.x + "" "" + t2.x),    }    Two fix(Two tt)     {        tt.x = 42,        return tt,    }}",null null 42,0 0 42,0 42 42,0 0 0, ,C," <p>In the <i class=""java-code"">fix()</i> method, the reference variable <i class=""java-code"">tt</i> refers to the same object (class <i class=""java-code"">Two</i>) as the <i class=""java-code"">t</i> reference variable. Updating <i class=""java-code"">tt.x</i> in the <i class=""java-code"">fix()</i> method updates <i class=""java-code"">t.x</i> (they are one in the same object). Remember also that the instance variable <i class=""java-code"">x</i> in the <i class=""java-code"">Two</i> class is initialized to 0.</p> "
Cse Engineering,Operators and Assignments, ,"What will be the output of the program?class BoolArray {    boolean [] b = new boolean[3],    int count = 0,    void set(boolean [] x, int i)     {        x[i] = true,        ++count,    }    public static void main(String [] args)     {        BoolArray ba = new BoolArray(),        ba.set(ba.b, 0),        ba.set(ba.b, 2),        ba.test(),    }    void test()     {        if ( b[0] && b[1] | b[2] )            count++,        if ( b[1] && b[(++count - 2)] )            count += 7,        System.out.println(""count = "" + count),    }}",count = 0,count = 2,count = 3,count = 4, ,C," <p>The reference variables <i class=""java-code"">b</i> and <i class=""java-code"">x</i> both refer to the same boolean array. <i class=""java-code"">count</i> is incremented for each call to the <i class=""java-code"">set()</i> method, and once again when the first if test is <i class=""java-code"">true</i>. Because of the <i class=""java-code"">&amp,&amp,</i> short circuit operator, <i class=""java-code"">count</i> is not incremented during the second <i class=""java-code"">if</i> test.</p> "
Cse Engineering,Operators and Assignments, ,"What will be the output of the program?public class Test {     public static void leftshift(int i, int j)     {        i <<= j,     }     public static void main(String args[])     {        int i = 4, j = 2,         leftshift(i, j),         System.out.printIn(i),     } }",2,4,8,16, ,B," <p> Java only ever passes arguments to a method by value (i.e. a copy of the variable) and never by reference. Therefore the value of the variable <i class=""java-code"">i</i> remains unchanged in the <i class=""java-code"">main</i> method.</p><p>If you are clever you will spot that 16 is 4 multiplied by 2 twice, (4 * 2 * 2) = 16. If you had 16 left shifted by three bits then 16 * 2 * 2 * 2 = 128. If you had 128 right shifted by 2 bits then 128 / 2 / 2 = 32. Keeping these points in mind, you don't have to go converting to binary to do the left and right bit shifts. </p> "
Cse Engineering,Exceptions, ,"What will be the output of the program?public class Foo {      public static void main(String[] args)     {        try         {             return,         }         finally         {            System.out.println( ""Finally"" ),         }     } }",Finally,Compilation fails.,The code runs with no output.,An exception is thrown at runtime., ,A," If you put a finally block after a try and its associated catch blocks, then once execution enters the try block, the code in that finally block will definitely be executed except in the following circumstances:<ol class=""java-ol-1234""><li>An exception arising in the finally block itself.</li><li>The death of the thread.</li><li>The use of <i class=""java-code"">System.exit()</i></li><li>Turning off the power to the CPU.</li></ol><p>I suppose the last three could be classified as VM shutdown.</p> "
Cse Engineering,Exceptions, ,"What will be the output of the program?try {     int x = 0,     int y = 5 / x, } catch (Exception e) {    System.out.println(""Exception""), } catch (ArithmeticException ae) {    System.out.println("" Arithmetic Exception""), } System.out.println(""finished""),",finished,Exception,Compilation fails.,Arithmetic Exception, ,C," <p>Compilation fails because <i class=""java-code"">ArithmeticException</i> has already been caught. <i class=""java-code"">ArithmeticException</i> is a subclass of <i class=""java-code"">java.lang.Exception</i>, by time the <i class=""java-code"">ArithmeticException</i> has been specified it has already been caught by the <i class=""java-code"">Exception</i> class.</p><p>If <i class=""java-code"">ArithmeticException</i> appears before <i class=""java-code"">Exception</i>, then the file will compile. When catching exceptions the more specific exceptions must be listed before the more general (the subclasses must be caught before the superclasses).</p> "
Cse Engineering,Exceptions, ,"What will be the output of the program?public class X {      public static void main(String [] args)     {        try         {            badMethod(),              System.out.print(""A""),         }          catch (Exception ex)         {            System.out.print(""B""),          }         finally         {            System.out.print(""C""),         }         System.out.print(""D""),     }      public static void badMethod()     {        throw new Error(), /* Line 22 */    } }",ABCD,Compilation fails.,C is printed before exiting with an error message.,BC is printed before exiting with an error message., ,C," <p><i class=""java-code"">Error</i> is thrown but not recognised line(22) because the only catch attempts to catch an <i class=""java-code"">Exception</i> and <i class=""java-code"">Exception</i> is not a superclass of <i class=""java-code"">Error</i>. Therefore only the code in the <i class=""java-code"">finally</i> statement can be run before exiting with a runtime error (Exception in thread ""main"" <i class=""java-code"">java.lang.Error</i>). </p> "
Cse Engineering,Exceptions, ,"What will be the output of the program?public class X {      public static void main(String [] args)     {        try         {            badMethod(),              System.out.print(""A""),          }         catch (RuntimeException ex) /* Line 10 */        {             System.out.print(""B""),         }         catch (Exception ex1)         {             System.out.print(""C""),         }         finally         {            System.out.print(""D""),         }         System.out.print(""E""),     }     public static void badMethod()     {         throw new RuntimeException(),     } }",BD,BCD,BDE,BCDE, ,C, <p>A Run time exception is thrown and caught in the catch statement on line 10. All the code after the finally statement is run because the exception has been caught.</p> 
Cse Engineering,Exceptions, ,"What will be the output of the program?public class RTExcept {    public static void throwit ()     {        System.out.print(""throwit ""),        throw new RuntimeException(),    }    public static void main(String [] args)     {        try         {            System.out.print(""hello ""),            throwit(),        }        catch (Exception re )         {            System.out.print(""caught ""),        }        finally         {            System.out.print(""finally ""),        }        System.out.println(""after ""),    }}",hello throwit caught,Compilation fails,hello throwit RuntimeException caught after,hello throwit caught finally after, ,D," <p>The <i class=""java-code"">main()</i> method properly catches and handles the <i class=""java-code"">RuntimeException</i> in the catch block, finally runs (as it always does), and then the code returns to normal.</p><p>A, B and C are incorrect based on the program logic described above. Remember that properly handled exceptions do not cause the program to stop executing.</p> "
Cse Engineering,Exceptions, ,"What will be the output of the program?public class Test {      public static void aMethod() throws Exception     {        try /* Line 5 */        {            throw new Exception(), /* Line 7 */        }         finally /* Line 9 */        {            System.out.print(""finally ""), /* Line 11 */        }     }     public static void main(String args[])     {        try         {            aMethod(),          }         catch (Exception e) /* Line 20 */        {            System.out.print(""exception ""),         }         System.out.print(""finished""), /* Line 24 */    } }",finally,exception finished,finally exception finished,Compilation fails, ,C," <p>This is what happens: </p><p></p><p>(1) The execution of the <i class=""java-code"">try</i> block (line 5) completes abruptly because of the <i class=""java-code"">throw</i> statement (line 7).</p><p>(2) The exception cannot be assigned to the parameter of any catch clause of the <i class=""java-code"">try</i> statement therefore the <i class=""java-code"">finally</i> block is executed (line 9) and ""finally"" is output (line 11).</p><p>(3) The <i class=""java-code"">finally</i> block completes normally, and then the <i class=""java-code"">try</i> statement completes abruptly because of the <i class=""java-code"">throw</i> statement (line 7).</p><p>(4) The exception is propagated up the call stack and is caught by the catch in the main method (line 20). This prints ""exception"".</p><p>(5) Lastly program execution continues, because the exception has been caught, and ""finished"" is output (line 24).</p> "
Cse Engineering,Exceptions, ,"What will be the output of the program?public class X {     public static void main(String [] args)     {        try         {            badMethod(),              System.out.print(""A""),         }          catch (Exception ex)         {            System.out.print(""B""),         }          finally         {            System.out.print(""C""),         }          System.out.print(""D""),     }      public static void badMethod() {} } ",AC,BC,ACD,ABCD, ,C," <p>There is no exception thrown, so all the code with the exception of the catch statement block is run.</p> "
Cse Engineering,Exceptions, ,"What will be the output of the program?public class X {      public static void main(String [] args)     {        try         {            badMethod(), /* Line 7 */            System.out.print(""A""),         }         catch (Exception ex) /* Line 10 */        {            System.out.print(""B""), /* Line 12 */        }         finally /* Line 14 */        {            System.out.print(""C""), /* Line 16 */        }          System.out.print(""D""), /* Line 18 */    }     public static void badMethod()     {        throw new RuntimeException(),     } }",AB,BC,ABC,BCD, ,D," <p>(1) A <i class=""java-code"">RuntimeException</i> is thrown, this is a subclass of exception.</p><p>(2) The exception causes the <i class=""java-code"">try</i> to complete abruptly (line 7) therefore line 8 is never executed.</p><p>(3) The exception is caught (line 10) and ""B"" is output (line 12)</p><p>(4) The <i class=""java-code"">finally</i> block (line 14) is always executed and ""C"" is output (line 16).</p><p>(5) The exception was caught, so the program continues with line 18 and outputs ""D"".</p> "
Cse Engineering,Exceptions, ,"What will be the output of the program?public class MyProgram {    public static void main(String args[])    {        try         {            System.out.print(""Hello world ""),        }        finally         {            System.out.println(""Finally executing ""),        }    }}",Nothing. The program will not compile because no exceptions are specified.,Nothing. The program will not compile because no catch clauses are specified.,Hello world.,Hello world Finally executing, ,D," <p>Finally clauses are always executed. The program will first execute the <i class=""java-code"">try</i> block, printing Hello world, and will then execute the finally block, printing Finally executing.</p><p>Option A, B, and C are incorrect based on the program logic described above. Remember that either a catch or a finally statement must follow a try. Since the finally is present, the catch is not required.</p> "
Cse Engineering,Exceptions, ,"What will be the output of the program?class Exc0 extends Exception { } class Exc1 extends Exc0 { } /* Line 2 */public class Test {      public static void main(String args[])     {         try         {              throw new Exc1(), /* Line 9 */        }         catch (Exc0 e0) /* Line 11 */        {            System.out.println(""Ex0 caught""),         }         catch (Exception e)         {            System.out.println(""exception caught""),          }     } }",Ex0 caught,exception caught,Compilation fails because of an error at line 2.,Compilation fails because of an error at line 9., ,A," <p>An exception <i class=""java-code"">Exc1</i> is thrown and is caught by the catch statement on line 11. The code is executed in this block. There is no finally block of code to execute.</p> "
Cse Engineering,Inner Classes, ,Which is true about an anonymous inner class?,It can extend exactly one class and implement exactly one interface.,It can extend exactly one class and can implement multiple interfaces.,It can extend exactly one class or implement exactly one interface.,It can implement multiple interfaces regardless of whether it also extends a class., ,C," <p>Option C is correct because the syntax of an anonymous inner class allows for only one named type after the new, and that type must be either a single interface (in which case the anonymous class implements that one interface) or a single class (in which case the anonymous class extends that one class).</p><p>Option A, B, D, and E are all incorrect because they don't follow the syntax rules described in the response for answer Option C.</p> "
Cse Engineering,Inner Classes, ,"class Boo {    Boo(String s) { }    Boo() { }}class Bar extends Boo {    Bar() { }    Bar(String s) {super(s),}    void zoo()     {    // insert code here    }}which one create an anonymous inner class from within class Bar?","Boo f = new Boo(24) { },","Boo f = new Bar() { },","Bar f = new Boo(String s) { },","Boo f = new Boo.Bar(String s) { },", ,B," <p>Option B is correct because anonymous inner classes are no different from any other class when it comes to polymorphism. That means you are always allowed to declare a reference variable of the superclass type and have that reference variable refer to an instance of a subclass type, which in this case is an anonymous subclass of <i class=""java-code"">Bar</i>. Since Bar is a subclass of <i class=""Java-code"">Boo</i>, it all works.</p><p>Option A is incorrect because it passes an int to the <i class=""Java-code"">Boo</i> constructor, and there is no matching constructor in the <i class=""Java-code"">Boo</i> class.</p><p>Option C is incorrect because it violates the rules of polymorphismâyou cannot refer to a superclass type using a reference variable declared as the subclass type. The superclass is not guaranteed to have everything the subclass has.</p><p>Option D uses incorrect syntax.</p> "
Cse Engineering,Inner Classes, ,Which is true about a method-local inner class?,It must be marked final.,It can be marked abstract.,It can be marked public.,It can be marked static., ,B," <p>Option B is correct because a method-local inner class can be <i class=""java-code"">abstract</i>, although it means a subclass of the inner class must be created if the abstract class is to be used (so an abstract method-local inner class is probably not useful).</p><p>Option A is incorrect because a method-local inner class does not have to be declared <i class=""Java-code"">final</i> (although it is legal to do so).</p><p>C and D are incorrect because a method-local inner class cannot be made <i class=""Java-code"">public</i> (remember-you cannot mark any local variables as <i class=""Java-code"">public</i>), or <i class=""Java-code"">static</i>.</p> "
Cse Engineering,Inner Classes, ,Which statement is true about a static nested class?,You must have a reference to an instance of the enclosing class in order to instantiate it.,It does not have access to nonstatic members of the enclosing class.,It's variables and methods must be static.,It must extend the enclosing class., ,B," <p>Option B is correct because a static nested class is not tied to an instance of the enclosing class, and thus can't access the nonstatic members of the class (just as a static method can't access nonstatic members of a class).</p><p>Option A is incorrect because static nested classes do not need (and can't use) a reference to an instance of the enclosing class.</p><p>Option C is incorrect because static nested classes can declare and define nonstatic members.</p><p>Option D is wrong because it just is. There's no rule that says an inner or nested class has to extend anything.</p> "
Cse Engineering,Inner Classes, ,Which constructs an anonymous inner class instance?,"Runnable r = new Runnable() { },","Runnable r = new Runnable(public void run() { }),","Runnable r = new Runnable { public void run(){}},","System.out.println(new Runnable() {public void run() { }}),", ,D," <p>D is correct. It defines an anonymous inner class instance, which also means it creates an instance of that new anonymous class at the same time. The anonymous class is an implementer of the <i class=""java-code"">Runnable</i> interface, so it must override the <i class=""Java-code"">run()</i> method of <i class=""Java-code"">Runnable</i>.</p><p>A is incorrect because it doesn't override the <i class=""Java-code"">run()</i> method, so it violates the rules of interface implementation.</p><p>B and C use incorrect syntax.</p> "
Cse Engineering,Inner Classes, ,"class Foo {    class Bar{ }}class Test {    public static void main (String [] args)     {        Foo f = new Foo(),        /* Line 10: Missing statement ? */    }}which statement, inserted at line 10, creates an instance of Bar?","Foo.Bar b = new Foo.Bar(),","Foo.Bar b = f.new Bar(),","Bar b = new f.Bar(),","Bar b = f.new Bar(),", ,B," <p>Option B is correct because the syntax is correct-using both names (the enclosing class and the inner class) in the reference declaration, then using a reference to the enclosing class to invoke new on the inner class.</p><p>Option A, C and D all use incorrect syntax. A is incorrect because it doesn't use a reference to the enclosing class, and also because it includes both names in the new.</p><p>C is incorrect because it doesn't use the enclosing class name in the reference variable declaration, and because the new syntax is wrong.</p><p>D is incorrect because it doesn't use the enclosing class name in the reference variable declaration.</p> "
Cse Engineering,Inner Classes, ,"public class MyOuter {    public static class MyInner     {        public static void foo() { }    }} which statement, if placed in a class other than MyOuter or MyInner, instantiates an instance of the nested class?","MyOuter.MyInner m = new MyOuter.MyInner(),","MyOuter.MyInner mi = new MyInner(),","MyOuter m = new MyOuter(),MyOuter.MyInner mi = m.new MyOuter.MyInner(),","MyInner mi = new MyOuter.MyInner(),", ,A," <p><i class=""java-code"">MyInner</i> is a static nested class, so it must be instantiated using the fully-scoped name of <i class=""Java-code"">MyOuter.MyInner</i>.</p><p>Option B is incorrect because it doesn't use the enclosing name in the new.</p><p>Option C is incorrect because it uses incorrect syntax. When you instantiate a nested class by invoking new on an instance of the enclosing class, you do not use the enclosing name. The difference between Option A and C is that Option C is calling new on an instance of the enclosing class rather than just new by itself. </p><p>Option D is incorrect because it doesn't use the enclosing class name in the variable declaration.</p> "
Cse Engineering,Garbage Collections, ,"void start() {      A a = new A(),     B b = new B(),     a.s(b),      b = null, /* Line 5 */    a = null,  /* Line 6 */    System.out.println(""start completed""), /* Line 7 */} When is the B object, created in line 3, eligible for garbage collection?",after line 5,after line 6,after line 7,There is no way to be absolutely certain., ,D," No answer description available for this question. <a href=""discussion-206"">Let us discuss</a>. "
Cse Engineering,Garbage Collections, ,"class HappyGarbage01 {     public static void main(String args[])     {        HappyGarbage01 h = new HappyGarbage01(),         h.methodA(), /* Line 6 */    }     Object methodA()     {        Object obj1 = new Object(),         Object [] obj2 = new Object[1],         obj2[0] = obj1,         obj1 = null,         return obj2[0],     } }Where will be the most chance of the garbage collector being invoked?",After line 9,After line 10,After line 11,Garbage collector never invoked in methodA(), ,D," <p>Option D is correct. Garbage collection takes place after the method has returned its reference to the object. The method returns to line 6, there is no reference to store the return value. so garbage collection takes place after line 6. </p><p>Option A is wrong. Because the reference to <i class=""java-code"">obj1</i> is stored in <i class=""java-code"">obj2[0]</i>. The Object <i class=""java-code"">obj1</i> still exists on the heap and can be accessed by an active thread through the reference stored in <i class=""java-code"">obj2[0]</i>. </p><p>Option B is wrong. Because it is only one of the references to the object <i class=""java-code"">obj1</i>, the other reference is maintained in <i class=""java-code"">obj2[0]</i>. </p><p>Option C is wrong. The garbage collector will not be called here because a reference to the object is being maintained and returned in <i class=""java-code"">obj2[0]</i>. </p> "
Cse Engineering,Garbage Collections, ,"class Bar { } class Test {      Bar doBar()     {        Bar b = new Bar(), /* Line 6 */        return b, /* Line 7 */    }     public static void main (String args[])     {         Test t = new Test(),  /* Line 11 */        Bar newBar = t.doBar(),  /* Line 12 */        System.out.println(""newBar""),         newBar = new Bar(), /* Line 14 */        System.out.println(""finishing""), /* Line 15 */    } }At what point is the Bar object, created on line 6, eligible for garbage collection?",after line 12,after line 14,"after line 7, when doBar() completes","after line 15, when main() completes", ,B," <p>Option B is correct. All references to the <i class=""java-code"">Bar</i> object created on line 6 are destroyed when a new reference to a new <i class=""java-code"">Bar</i> object is assigned to the variable <i class=""java-code"">newBar</i> on line 14. Therefore the <i class=""java-code"">Bar</i> object, created on line 6, is eligible for garbage collection after line 14. </p><p>Option A is wrong. This actually protects the object from garbage collection.</p><p>Option C is wrong. Because the reference in the <i class=""java-code"">doBar()</i> method is returned on line 7 and is stored in <i class=""java-code"">newBar</i> on line 12. This preserver the object created on line 6. </p><p>Option D is wrong. Not applicable because the object is eligible for garbage collection after line 14. </p> "
Cse Engineering,Garbage Collections, ,"class Test {      private Demo d,     void start()     {          d = new Demo(),         this.takeDemo(d), /* Line 7 */    } /* Line 8 */    void takeDemo(Demo demo)     {         demo = null,          demo = new Demo(),     } }When is the Demo object eligible for garbage collection?",After line 7,After line 8,After the start() method completes,When the instance running this code is made eligible for garbage collection., ,D," <p>Option D is correct. By a process of elimination.</p><p>Option A is wrong. The variable <i class=""java-code"">d</i> is a member of the <i class=""java-code"">Test</i> class and is never directly set to null. </p><p>Option B is wrong. A copy of the variable <i class=""java-code"">d</i> is set to null and not the actual variable <i class=""java-code"">d</i>. </p><p>Option C is wrong. The variable <i class=""java-code"">d</i> exists outside the <i class=""java-code"">start()</i> method (it is a class member). So, when the <i class=""java-code"">start()</i> method finishes the variable <i class=""java-code"">d</i> still holds a reference.</p> "
Cse Engineering,Garbage Collections, ,"public class X {    public static void main(String [] args)     {        X x = new X(),        X x2 = m1(x), /* Line 6 */        X x4 = new X(),        x2 = x4, /* Line 8 */        doComplexStuff(),    }    static X m1(X mx)     {        mx = new X(),        return mx,    }}After line 8 runs. how many objects are eligible for garbage collection?",0 Â ,1,2,3, ,B," <p>By the time line 8 has run, the only object without a reference is the one generated as a result of line 6. Remember that ""Java is pass by value,"" so the reference variable <i class=""java-code"">x</i> is not affected by the <i class=""java-code"">m1()</i> method.</p><p>Ref: http://www.javaworld.com/javaworld/javaqa/2000-05/03-qa-0526-pass.html</p> "
Cse Engineering,Garbage Collections, ,"public Object m() {      Object o = new Float(3.14F),     Object [] oa = new Object[l],    oa[0] = o, /* Line 5 */    o = null,  /* Line 6 */    oa[0] = null, /* Line 7 */    return o, /* Line 8 */}When is the Float object, created in line 3, eligible for garbage collection?",just after line 5,just after line 6,just after line 7,just after line 8, ,C," <p>Option A is wrong. This simply copies the object reference into the array.</p><p>Option B is wrong. The reference o is set to null, but, <i class=""java-code"">oa[0]</i> still maintains the reference to the <i class=""java-code"">Float</i> object.</p><p>Option C is correct. The thread of execution will then not have access to the object.</p> "
Cse Engineering,Garbage Collections, ,"class X2 {    public X2 x,    public static void main(String [] args)     {        X2 x2 = new X2(),  /* Line 6 */        X2 x3 = new X2(),  /* Line 7 */        x2.x = x3,        x3.x = x2,        x2 = new X2(),        x3 = x2, /* Line 11 */        doComplexStuff(),    }}after line 11 runs, how many objects are eligible for garbage collection?",0,1,2,3, ,C," <p>This is an example of the islands of isolated objects. By the time line 11 has run, the objects instantiated in lines 6 and 7 are referring to each other, but no live thread can reach either of them.</p> "
Cse Engineering,Garbage Collections, ,What allows the programmer to destroy an object x?,x.delete(),x.finalize(),Runtime.getRuntime().gc(),Only the garbage collection system can destroy an object., ,D," <p>Option D is correct. When an object is no longer referenced, it may be reclaimed by the garbage collector. If an object declares a finalizer, the finalizer is executed before the object is reclaimed to give the object a last chance to clean up resources that would not otherwise be released. When a class is no longer needed, it may be unloaded. </p><p>Option A is wrong. I found 4 <i class=""java-code"">delete()</i> methods in all of the Java class structure. They are:</p>  <p></p><ol class=""java-ol-1234""><li><i class=""java-code"">delete()</i> - Method in class <i class=""java-code"">java.io.File</i> : Deletes the file or directory denoted by this abstract pathname.</li><li><i class=""java-code"">delete(int, int)</i> - Method in class <i class=""java-code"">java.lang.StringBuffer</i> : Removes the characters in a substring of this <i class=""java-code"">StringBuffer</i>.</li><li><i class=""java-code"">delete(int, int)</i> - Method in interface <i class=""java-code"">javax.accessibility.AccessibleEditableText</i> : Deletes the text between two indices</li><li><i class=""java-code"">delete(int, int)</i> - Method in class : <i class=""java-code"">javax.swing.text.JTextComponent.AccessibleJTextComponent</i>, Deletes the text between two indices</li></ol><p></p><p>None of these destroy the object to which they belong. </p><p>Option B is wrong. I found 19 <i class=""java-code"">finalize()</i> methods. The most interesting, from this questions point of view, was the <i class=""java-code"">finalize()</i> method in class <i class=""java-code"">java.lang.Object</i> which is called by the garbage collector on an object when garbage collection determines that there are no more references to the object. This method does not destroy the object to which it belongs. </p><p>Option C is wrong. But it is interesting. The <i class=""java-code"">Runtime</i> class has many methods, two of which are: </p><p></p><ol class=""java-ol-1234""><li><i class=""java-code"">getRuntime()</i> - Returns the runtime object associated with the current Java application.</li><li><i class=""java-code"">gc()</i> - Runs the garbage collector. Calling this method suggests that the Java virtual machine expend effort toward recycling unused objects in order to make the memory they currently occupy available for quick reuse. When control returns from the method call, the virtual machine has made its best effort to recycle all discarded objects. Interesting as this is, it doesn't destroy the object.</li></ol> "
Cse Engineering,Java.lang Class, ,"What is the value of ""d"" after this line of code has been executed?double d = Math.round ( 2.5 + Math.random() ),",2,3,4,2.5, ,B," <p>The <i class=""java-code"">Math.random()</i> method returns a number greater than or equal to <i class=""java-code"">0</i> and less than <i class=""java-code"">1</i> . Since we can then be sure that the sum of that number and <i class=""java-code"">2.5</i> will be greater than or equal to <i class=""java-code"">2.5</i> and less than <i class=""java-code"">3.5</i>, we can be sure that <i class=""java-code"">Math.round()</i> will round that number to <i class=""java-code"">3</i>. So Option B is the answer.</p> "
Cse Engineering,Java.lang Class, ,Which of the following would compile without error?,"int a = Math.abs(-5),","int b = Math.abs(5.0),","int c = Math.abs(5.5F),","int d = Math.abs(5L),", ,A," <p>The return value of the <i class=""java-code"">Math.abs()</i> method is always the same as the type of the parameter passed into that method.</p><p>In the case of <i class=""java-code"">A</i>, an integer is passed in and so the result is also an integer which is fine for assignment to ""<i class=""java-code"">int a</i>"".</p><p>The values used in B, C &amp, D respectively are a <i class=""java-code"">double</i>, a float and a long. The compiler will complain about a possible loss of precision if we try to assign the results to an ""<i class=""java-code"">int</i>"".</p><p></p><p></p><p></p> "
Cse Engineering,Java.lang Class, ,"Which of the following are valid calls to Math.max?Math.max(1,4)Math.max(2.3, 5)Math.max(1, 3, 5, 7)Math.max(-1.5, -2.8f)","1, 2 and 4","2, 3 and 4","1, 2 and 3",3 and 4, ,A," <p>(1), (2), and (4) are correct. The <i class=""java-code"">max()</i> method is overloaded to take two arguments of type <i class=""java-code"">int</i>, <i class=""java-code"">long</i>, <i class=""java-code"">float</i>, or <i class=""java-code"">double</i>.</p><p>(3) is incorrect because the <i class=""java-code"">max()</i> method only takes two arguments.</p> "
Cse Engineering,Java.lang Class, ,"public class Myfile {     public static void main (String[] args)     {        String biz = args[1],         String baz = args[2],         String rip = args[3],         System.out.println(""Arg is "" + rip),     } }Select how you would start the program to cause it to print: Arg is 2",java Myfile 222,java Myfile 1 2 2 3 4,java Myfile 1 3 2 2,java Myfile 0 1 2 3, ,C," <p>Arguments start at array element <i class=""java-code"">0</i> so the fourth arguement must be <i class=""java-code"">2</i> to produce the correct output. </p> "
Cse Engineering,Declarations and Access Control, ,You want subclasses in any package to have access to members of a superclass. Which is the most restrictive access that accomplishes this objective?,public,private,protected,transient, ,C," <p>Access modifiers dictate which classes, not which instances, may access features. </p><p>Methods and variables are collectively known as members. Method and variable members are given access control in exactly the same way. </p> <p><i class=""java-code"">private</i> makes a member accessible only from within its own class </p><p><i class=""java-code"">protected</i> makes a member accessible only to classes in the same package or subclass of the class </p><p><i class=""java-code"">default</i> access is very similar to protected (make sure you spot the difference) default access makes a member accessible only to classes in the same package.</p><p><i class=""java-code"">public</i> means that all other classes regardless of the package that they belong to, can access the member (assuming the class itself is visible) </p><p><i class=""java-code"">final</i> makes it impossible to extend a class, when applied to a method it prevents a method from being overridden in a subclass, when applied to a variable it makes it impossible to reinitialise a variable once it has been initialised</p><p><i class=""java-code"">abstract</i> declares a method that has not been implemented.</p><p><i class=""java-code"">transient</i> indicates that a variable is not part of the persistent state of an object.</p><p><i class=""java-code"">volatile</i> indicates that a thread must reconcile its working copy of the field with the master copy every time it accesses the variable.</p> <p>After examining the above it should be obvious that the access modifier that provides the most restrictions for methods to be accessed from the subclasses of the class from another package is C - <i class=""java-code"">protected</i>. A is also a contender but C is more restrictive, B would be the answer if the constraint was the ""same package"" instead of ""any package"" in other words the subclasses clause in the question eliminates default.</p> "
Cse Engineering,Declarations and Access Control, ,"public class Outer {     public void someOuterMethod()     {        //Line 5     }     public class Inner { }         public static void main(String[] argv)     {        Outer ot = new Outer(),         //Line 10    } } Which of the following code fragments inserted, will allow to compile?","new Inner(), //At line 5","new Inner(), //At line 10","new ot.Inner(), //At line 10","new Outer.Inner(), //At line 10", ,A," <p>Option A compiles without problem.</p><p>Option B gives error - non-static variable cannot be referenced from a static context.</p><p>Option C package <i class=""java-code"">ot</i> does not exist.</p><p>Option D gives error - non-static variable cannot be referenced from a static context.</p> "
Cse Engineering,Declarations and Access Control, ,"interface Base {    boolean m1 (),    byte m2(short s),}which two code fragments will compile?interface Base2 implements Base {}abstract class Class2 extends Base { public boolean m1(){ return true, }}abstract class Class2 implements Base {}abstract class Class2 implements Base  { public boolean m1(){ return (7 > 4), }}abstract class Class2 implements Base { protected boolean m1(){ return (5 > 7) }}",1 and 2,2 and 3,3 and 4,1 and 5, ,C," <p>(3) is correct because an abstract class doesn't have to implement any or all of its interface's methods. (4) is correct because the method is correctly implemented (<i class=""java-code"">(7 &gt, 4)</i> is a boolean).</p><p>(1) is incorrect because interfaces don't implement anything. (2) is incorrect because classes don't extend interfaces. (5) is incorrect because interface methods are implicitly <i class=""java-code"">public</i>, so the methods being implemented must be <i class=""java-code"">public</i>.</p> "
Cse Engineering,Declarations and Access Control, ,Which three form part of correct array declarations?public int a [ ]static int [ ] apublic [ ] int aprivate int a [3]private int [3] a [ ]public final int [ ] a,"1, 3, 4","2, 4, 5","1, 2, 6","2, 5, 6", ,C," <p>(1), (2) and (6) are valid array declarations.</p><p>Option (3) is not a correct array declaration. The compiler complains with: illegal start of type. The brackets are in the wrong place. The following would work: <i class=""java-code"">public int[ ] a</i></p><p>Option (4) is not a correct array declaration. The compiler complains with: '<i class=""java-code"">]</i>' expected. A closing bracket is expected in place of the 3. The following works: <i class=""java-code"">private int a []</i></p><p>Option (5) is not a correct array declaration. The compiler complains with 2 errors:</p><p>'<i class=""java-code"">]</i>' expected. A closing bracket is expected in place of the 3 and </p><p>&lt,identifier&gt, expected A variable name is expected after <i class=""java-code"">a[ ]</i> .</p> "
Cse Engineering,Declarations and Access Control, ,public class Test { }What is the prototype of the default constructor?,Test( ),Test(void),public Test( ),public Test(void), ,C," <p>Option A and B are wrong because they use the default access modifier and the access modifier for the class is <i class=""java-code"">public</i> (remember, the default constructor has the same access modifier as the class).</p><p>Option D is wrong. The void makes the compiler think that this is a method specification - in fact if it were a method specification the compiler would spit it out.</p> "
Cse Engineering,Declarations and Access Control, ,What is the most restrictive access modifier that will allow members of one class to have access to members of another class in the same package?,public,abstract,protected,synchronized,default access,E," <p><i class=""java-code"">default</i> access is the ""package oriented"" access modifier.</p><p>Option A and C are wrong because <i class=""java-code"">public</i> and <i class=""java-code"">protected</i> are less restrictive. Option B and D are wrong because <i class=""java-code"">abstract</i> and <i class=""java-code"">synchronized</i> are not access modifiers.</p> "
Cse Engineering,Declarations and Access Control, ,"Which of the following is/are legal method declarations?protected abstract void m1(),static final void m1(){}synchronized public final void m1() {}private native void m1(),",1 and 3,2 and 4,1 only,All of them are legal declarations., ,D, <p>All the given statements are legal declarations.</p> 
Cse Engineering,Declarations and Access Control, ,Which cause a compiler error?,"int[ ] scores = {3, 5, 7},","int [ ][ ] scores = {2,7,6}, {9,3,45},","String cats[ ] = {""Fluffy"", ""Spot"", ""Zeus""},","boolean results[ ] = new boolean [] {true, false, true},","Integer results[ ] = {new Integer(3), new Integer(5), new Integer(8)},",B," <p>Option B generates a compiler error: &lt,identifier&gt, expected. The compiler thinks you are trying to create two arrays because there are two array initialisers to the right of the equals, whereas your intention was to create one 3 x 3 two-dimensional array.</p><p>To correct the problem and make option B compile you need to add an extra pair of curly brackets:</p><p>int [ ] [ ] scores = { {2,7,6}, {9,3,45} },</p><p></p><p></p><p></p> "
Cse Engineering,Declarations and Access Control, ,"Which three are valid method signatures in an interface?private int getArea(),public float getVol(float x),public void main(String [] args),public static void main(String [] args),boolean setFlag(Boolean [] test),",1 and 2,"2, 3 and 5","3, 4, and 5",2 and 4, ,B," <p>(2), (3), and (5). These are all valid interface method signatures.</p><p>(1), is incorrect because an interface method must be <i class=""java-code"">public</i>, if it is not explicitly declared <i class=""java-code"">public</i> it will be made public implicitly. (4) is incorrect because interface methods cannot be <i class=""java-code"">static</i>.</p> "
Cse Engineering,Declarations and Access Control, ,You want a class to have access to members of another class in the same package. Which is the most restrictive access that accomplishes this objective?,public,private,protected,default access, ,D," <p>The only two real contenders are C and D. <i class=""java-code"">Protected</i> access Option C makes a member accessible only to classes in the same package or subclass of the class. While default access Option D makes a member accessible only to classes in the same package. </p> "
Cse Engineering,Declarations and Access Control, ,"What is the widest valid returnType for methodA in line 3? public class ReturnIt {     returnType methodA(byte x, double y) /* Line 3 */    {         return (long)x / y * 2,     } }",int,byte,long,double, ,D," <p>However A, B and C are all wrong. Each of these would result in a narrowing conversion. Whereas we want a widening conversion, therefore the only correct answer is D. Don't be put off by the <i class=""java-code"">long</i> cast, this applies only to the variable x and not the rest of the expression. It is the variable y (of type <i class=""java-code"">double</i>) that forces the widening conversion to <i class=""java-code"">double</i>.</p> <p>Java's widening conversions are:</p><p>- From a byte to a short, an int, a long, a float, or a double.</p><p>- From a short, an int, a long, a float, or a double.</p><p>- From a char to an int, a long, a float, or a double.</p><p>- From an int to a long, a float, or a double.</p><p>- From a long to a float, or a double.</p><p>- From a float to a double.</p><p></p> "
Cse Engineering,Declarations and Access Control, ,"class A {      protected int method1(int a, int b)     {        return 0,     } }Which is valid in a class that extends class A?","public int method1(int a, int b) {return 0, }","private int method1(int a, int b) { return 0, }","public short method1(int a, int b) { return 0, }","static protected int method1(int a, int b) { return 0, }", ,A," <p>Option A is correct - because the class that extends <i class=""java-code"">A</i> is just simply overriding <i class=""java-code"">method1</i>.</p><p>Option B is wrong - because it can't override as there are less access privileges in the subclass <i class=""java-code"">method1</i>. </p><p>Option C is wrong - because to override it, the return type needs to be an integer. The different return type means that the method is not overriding but the same argument list means that the method is not overloading. Conflict - compile time error. </p><p>Option D is wrong - because you can't override a method and make it a class method i.e. using <i class=""java-code"">static</i>.</p> "
Cse Engineering,Declarations and Access Control, ,Which one creates an instance of an array?,"int[ ] ia = new int[15],","float fa = new float[20],","char[ ] ca = ""Some String"",","int ia[ ] [ ] = { 4, 5, 6 }, { 1,2,3 },", ,A," <p>Option A is correct. It uses correct array declaration and correct array construction.</p><p>Option B is incorrect. It generates a compiler error: incompatible types because the array variable declaration is not correct. The array construction expects a reference type, but it is supplied with a primitive type in the declaration.</p><p>Option C is incorrect. It generates a compiler error: incompatible types because a string literal is not assignable to a character type variable. </p><p>Option D is wrong, it generates a compiler error &lt,identifier&gt, expected. The compiler thinks that you are trying to create two arrays because there are two array initialisers to the right of the equals, whereas your intention was to create a 3 x 3 two-dimensional array.</p> "
Cse Engineering,Declarations and Access Control, ,Which two of the following are legal declarations for nonnested classes and interfaces?final abstract class Test {}public static interface Test {}final public class Test {}protected abstract class Test {}protected interface Test {}abstract public class Test {},1 and 4,2 and 5,3 and 6,4 and 6, ,C," <p>(3), (6). Both are legal class declarations.</p><p>(1) is wrong because a class cannot be <i class=""java-code"">abstract</i> and <i class=""java-code"">final</i>âthere would be no way to use such a class. (2) is wrong because interfaces and classes cannot be marked as <i class=""java-code"">static</i>. (4) and (5) are wrong because classes and interfaces cannot be marked as <i class=""java-code"">protected</i>.</p> "
Cse Engineering,Declarations and Access Control, ,Which of the following class level (nonlocal) variable declarations will not compile?,"protected int a,","transient int b = 3,","private synchronized int e,","volatile int d,", ,C," <p>Option C will not compile, the <i class=""java-code"">synchronized</i> modifier applies only to methods.</p><p>Option A and B will compile because <i class=""java-code"">protected</i> and <i class=""java-code"">transient</i> are legal variable modifiers. Option D will compile because <i class=""java-code"">volatile</i> is a proper variable modifier.</p> "
Cse Engineering,Declarations and Access Control, ,"Which two cause a compiler error?float[ ] f = new float(3),float f2[ ] = new float[ ],float[ ]f1 = new float[3],float f3[ ] = new float[3],float f5[ ] = {1.0f, 2.0f, 2.0f},","2, 4","3, 5","4, 5","1, 2", ,D," <p>(1) causes two compiler errors ( '[' expected and illegal start of expression) because the wrong type of bracket is used, <i class=""java-code"">( )</i> instead of <i class=""java-code"">[ ]</i>. The following is  the correct syntax: <i class=""java-code"">float[ ] f = new float[3],</i></p><p>(2) causes a compiler error ( '{' expected ) because the array constructor does not specify the number of elements in the array. The following is the correct syntax: <i class=""java-code"">float f2[ ] = new float[3],</i> </p><p>(3), (4), and (5) compile without error.</p> "
Cse Engineering,Declarations and Access Control, ,"Given a method in a protected class, what access modifier do you use to restrict access to that method to only the other members of the same class?",final,static,private,protected,volatile,C," <p>The <i class=""java-code"">private</i> access modifier limits access to members of the same class.</p><p>Option A, B, D, and E are wrong because <i class=""java-code"">protected</i> are the wrong access modifiers, and <i class=""java-code"">final</i>, <i class=""java-code"">static</i>, and <i class=""java-code"">volatile</i> are modifiers but not access modifiers.</p> "
Cse Engineering,Declarations and Access Control, ,Which is a valid declaration within an interface?,"public static short stop = 23,","protected short stop = 23,","transient short stop = 23,","final void madness(short stop),", ,A," <p>(A) is valid interface declarations.</p><p>(B) and (C) are incorrect because interface variables cannot be either <i class=""java-code"">protected</i> or <i class=""java-code"">transient</i>. (D) is incorrect because interface methods cannot be <i class=""java-code"">final</i> or <i class=""java-code"">static</i>.</p> "
Cse Engineering,Flow Control, ,"public void foo( boolean a, boolean b){     if( a )     {        System.out.println(""A""), /* Line 5 */    }     else if(a && b) /* Line 7 */    {         System.out.println( ""A && B""),     }     else /* Line 11 */    {         if ( !b )         {            System.out.println( ""notB"") ,        }         else         {            System.out.println( ""ELSE"" ) ,         }     } }","If a is true and b is true then the output is ""A && B""","If a is true and b is false then the output is ""notB""","If a is false and b is true then the output is ""ELSE""","If a is false and b is false then the output is ""ELSE""", ,C," <p>Option C is correct. The output is ""<i class=""java-code"">ELSE</i>"". Only when a is false do the output lines after 11 get some chance of executing.</p><p>Option A is wrong. The output is ""<i class=""java-code"">A</i>"". When <i class=""java-code"">a</i> is true, irrespective of the value of <i class=""java-code"">b</i>, only the line 5 output will be executed. The condition at line 7 will never be evaluated (when a is true it will always be trapped by the line 12 condition) therefore the output will never be ""A &amp,&amp, B"". </p><p>Option B is wrong. The output is ""<i class=""java-code"">A</i>"". When <i class=""java-code"">a</i> is true, irrespective of the value of <i class=""java-code"">b</i>, only the line 5 output will be executed. </p><p>Option D is wrong. The output is ""<i class=""java-code"">notB</i>"".</p> "
Cse Engineering,Flow Control, ,"switch(x) {     default:          System.out.println(""Hello""), }Which two are acceptable types for x?bytelongcharfloatShortLong",1 and 3,2 and 4,3 and 5,4 and 6, ,A," <p><i class=""java-code"">Switch</i> statements are based on integer expressions and since both bytes and chars can implicitly be widened to an integer, these can also be used. Also shorts can be used. <i class=""java-code"">Short</i> and <i class=""java-code"">Long</i> are wrapper classes and reference types can not be used as variables.</p> "
Cse Engineering,Flow Control, ,"public void test(int x) {     int odd = 1,     if(odd) /* Line 4 */    {        System.out.println(""odd""),     }     else     {        System.out.println(""even""),     } }Which statement is true?",Compilation fails.,"""odd"" will always be output.","""even"" will always be output.","""odd"" will be output for odd values of x, and ""even"" for even values.", ,A," <p>The compiler will complain because of incompatible types (line 4), the if expects a boolean but it gets an integer.</p> "
Cse Engineering,Flow Control, ,"public class While {    public void loop()     {        int x= 0,        while ( 1 ) /* Line 6 */        {            System.out.print(""x plus one is "" + (x + 1)), /* Line 8 */        }    }}Which statement is true?",There is a syntax error on line 1.,There are syntax errors on lines 1 and 6.,"There are syntax errors on lines 1, 6, and 8.",There is a syntax error on line 6., ,D," <p>Using the integer <i class=""java-code"">1</i> in the while statement, or any other looping or conditional construct for that matter, will result in a compiler error. This is old C Program syntax, not valid Java.</p><p>A, B and C are incorrect because line 1 is valid (Java is case sensitive so While is a valid class name). Line 8 is also valid because an equation may be placed in a String operation as shown.</p> "
Cse Engineering,Objects and Collections, ,Suppose that you would like to create an instance of a new Map that has an iteration order that is the same as the iteration order of an existing instance of a Map. Which concrete implementation of the Map interface should be used for the new instance?,TreeMap,HashMap,LinkedHashMap,The answer depends on the implementation of the existing instance., ,C," <p> The iteration order of a <i class=""java-code"">Collection</i> is the order in which an iterator moves through the elements of the <i class=""java-code"">Collection</i>. The iteration order of a <i class=""java-code"">LinkedHashMap</i> is determined by the order in which elements are inserted. </p><p>When a new <i class=""java-code"">LinkedHashMap</i> is created by passing a reference to an existing Collection to the constructor of a <i class=""java-code"">LinkedHashMap</i> the <i class=""java-code"">Collection.addAll</i> method will ultimately be invoked. </p><p>The addAll method uses an iterator to the existing Collection to iterate through the elements of the existing Collection and add each to the instance of the new <i class=""java-code"">LinkedHashMap</i>. </p><p>Since the iteration order of the <i class=""java-code"">LinkedHashMap</i> is determined by the order of insertion, the iteration order of the new <i class=""java-code"">LinkedHashMap</i> must be the same as the interation order of the old <i class=""java-code"">Collection</i>. </p> "
Cse Engineering,Objects and Collections, ,"Which class does not override the equals() and hashCode() methods, inheriting them directly from class Object?",java.lang.String,java.lang.Double,java.lang.StringBuffer,java.lang.Character, ,C," <p><i class=""java-code"">java.lang.StringBuffer</i> is the only class in the list that uses the default methods provided by class <i class=""java-code"">Object</i>.</p> "
Cse Engineering,Objects and Collections, ,"Which collection class allows you to grow or shrink its size and provides indexed access to its elements, but whose methods are not synchronized?",java.util.HashSet,java.util.LinkedHashSet,java.util.List,java.util.ArrayList, ,D," <p>All of the collection classes allow you to grow or shrink the size of your collection. <i class=""java-code"">ArrayList</i> provides an index to its elements. The newer collection classes tend not to have synchronized methods. Vector is an older implementation of <i class=""java-code"">ArrayList</i> functionality and has synchronized methods, it is slower than <i class=""java-code"">ArrayList</i>.</p> "
Cse Engineering,Objects and Collections, ,You need to store elements in a collection that guarantees that no duplicates are stored and all elements can be accessed in natural order. Which interface provides that capability?,java.util.Map,java.util.Set,java.util.List,java.util.Collection, ,B," <p>Option B is correct. A set is a collection that contains no duplicate elements. The iterator returns the elements in no particular order (unless this set is an instance of some class that provides a guarantee). A map cannot contain duplicate keys but it may contain duplicate values. <i class=""java-code"">List</i> and <i class=""java-code"">Collection</i> allow duplicate elements. </p><p>Option A is wrong. A map is an object that maps keys to values. A map cannot contain duplicate keys, each key can map to at most one value. The <i class=""java-code"">Map</i> interface provides three collection views, which allow a map's contents to be viewed as a set of keys, collection of values, or set of key-value mappings. The order of a map is defined as the order in which the iterators on the map's collection views return their elements. Some map implementations, like the <i class=""java-code"">TreeMap</i> class, make specific guarantees as to their order (ascending key order), others, like the <i class=""java-code"">HashMap</i> class, do not (does not guarantee that the order will remain constant over time).</p><p>Option C is wrong. A list is an ordered collection (also known as a sequence). The user of this interface has precise control over where in the list each element is inserted. The user can access elements by their integer index (position in the list), and search for elements in the list. Unlike sets, lists typically allow duplicate elements.</p><p>Option D is wrong. A collection is also known as a sequence. The user of this interface has precise control over where in the list each element is inserted. The user can access elements by their integer index (position in the list), and search for elements in the list. Unlike sets, lists typically allow duplicate elements.</p> "
Cse Engineering,Objects and Collections, ,Which interface does java.util.Hashtable implement?,Java.util.Map,Java.util.List,Java.util.HashTable,Java.util.Collection, ,A," <p>Hash table based implementation of the <i class=""java-code"">Map</i> interface.</p> "
Cse Engineering,Objects and Collections, ,Which interface provides the capability to store objects using a key-value pair?,Java.util.Map,Java.util.Set,Java.util.List,Java.util.Collection, ,A," <p>An object that maps keys to values. A map cannot contain duplicate keys, each key can map to at most one value.</p> "
Cse Engineering,Objects and Collections, ,"Which collection class allows you to associate its elements with key values, and allows you to retrieve objects in FIFO (first-in, first-out) sequence?",java.util.ArrayList,java.util.LinkedHashMap,java.util.HashMap,java.util.TreeMap, ,B," <p><i class=""java-code"">LinkedHashMap</i> is the collection class used for caching purposes. FIFO is another way to indicate caching behavior. To retrieve <i class=""java-code"">LinkedHashMap</i> elements in cached order, use the <i class=""java-code"">values()</i> method and iterate over the resultant collection.</p> "
Cse Engineering,Objects and Collections, ,"Which collection class allows you to access its elements by associating a key with an element's value, and provides synchronization?",java.util.SortedMap,java.util.TreeMap,java.util.TreeSet,java.util.Hashtable, ,D," <p><i class=""java-code"">Hashtable</i> is the only class listed that provides synchronized methods. If you need synchronization great, otherwise, use <i class=""java-code"">HashMap</i>, it's faster.</p> "
Cse Engineering,Objects and Collections, ,Which is valid declaration of a float?,"float f = 1F,","float f = 1.0,","float f = ""1"",","float f = 1.0d,", ,A," <p>Option A is valid declaration of float.</p><p>Option B is incorrect because any literal number with a decimal point u declare the computer will implicitly cast to double unless you include ""F or f""</p><p>Option C is incorrect because it is a <i class=""java-code"">String</i>.</p><p>Option D is incorrect because ""d"" tells the computer it is a double so therefore you are trying to put a double value into a float variable i.e there might be a loss of precision.</p> "
Cse Engineering,Objects and Collections, ,"/* Missing Statement ? */public class foo {    public static void main(String[]args)throws Exception     {        java.io.PrintWriter out = new java.io.PrintWriter(),         new java.io.OutputStreamWriter(System.out,true),         out.println(""Hello""),     } }What line of code should replace the missing statement to make this program compile?",No statement required.,"import java.io.*,","include java.io.*,","import java.io.PrintWriter,", ,A," <p> The usual method for using/importing the java packages/classes is by using an import statement at the top of your code. However it is possible to explicitly import the specific class that you want to use as you use it which is shown in the code above. The disadvantage of this however is that every time you create a new object you will have to use the class path in the case ""<i class=""java-code"">java.io</i>"" then the class name in the long run leading to a lot more typing.</p> "
Cse Engineering,Objects and Collections, ,What is the numerical range of char?,0 to 32767,0 to 65535,-256 to 255,-32768 to 32767, ,B," <p> The char type is integral but unsigned. The range of a variable of type char is from <i class=""java-code"">0 to 2<sup>16</sup>-1</i> or <i class=""java-code"">0 to 65535</i>. Java characters are Unicode, which is a 16-bit encoding capable of representing a wide range of international characters. If the most significant nine bits of a <i class=""java-code"">char</i> are <i class=""java-code"">0</i>, then the encoding is the same as seven-bit ASCII.</p><p></p> "
Cse Engineering,Objects and Collections, ,Which of the following are Java reserved words?runimportdefaultimplement,1 and 2,2 and 3,3 and 4,2 and 4, ,B," <p>(2) - This is a Java keyword</p><p>(3) - This is a Java keyword </p><p>(1) - Is incorrect because although it is a method of <i class=""java-code"">Thread</i>/<i class=""java-code"">Runnable</i> it is not a keyword </p><p>(4) - This is not a Java keyword the keyword is implements</p> "
Cse Engineering,Threads, ,What is the name of the method used to start a thread execution?,"init(),","start(),","run(),","resume(),", ,B," <p>Option B is Correct. The <i class=""java-code"">start()</i> method causes this thread to begin execution, the Java Virtual Machine calls the run method of this thread. </p><p>Option A is wrong. There is no <i class=""java-code"">init()</i> method in the <i class=""java-code"">Thread</i> class.</p><p>Option C is wrong. The <i class=""java-code"">run()</i> method of a thread is like the main() method to an application. Starting the thread causes the object's run method to be called in that separately executing thread.</p><p>Option D is wrong. The <i class=""java-code"">resume()</i> method is deprecated. It resumes a suspended thread.</p> "
Cse Engineering,Threads, ,"Which two are valid constructors for Thread?Thread(Runnable r, String name)Thread()Thread(int priority)Thread(Runnable r, ThreadGroup g)Thread(Runnable r, int priority)",1 and 3,2 and 4,1 and 2,2 and 5, ,C," <p>(1) and (2) are both valid constructors for <i class=""java-code"">Thread</i>.</p><p>(3), (4), and (5) are not legal <i class=""java-code"">Thread</i> constructors, although (4) is close. If you reverse the arguments in (4), you'd have a valid constructor.</p> "
Cse Engineering,Threads, ,"Which three are methods of the Object class?notify(),notifyAll(),isInterrupted(),synchronized(),interrupt(),wait(long msecs),sleep(long msecs),yield(),","1, 2, 4","2, 4, 5","1, 2, 6","2, 3, 4", ,C," <p>(1), (2), and (6) are correct. They are all related to the list of threads waiting on the specified object.</p><p>(3), (5), (7), and (8) are incorrect answers. The methods <i class=""java-code"">isInterrupted()</i> and <i class=""java-code"">interrupt()</i> are instance methods of <i class=""java-code"">Thread</i>. </p><p>The methods <i class=""java-code"">sleep()</i> and <i class=""java-code"">yield()</i> are static methods of <i class=""java-code"">Thread</i>. </p><p>D is incorrect because <i class=""java-code"">synchronized</i> is a keyword and the <i class=""java-code"">synchronized()</i> construct is part of the Java language.</p> "
Cse Engineering,Threads, ,class X implements Runnable {     public static void main(String args[])     {        /* Missing code? */    }     public void run() {} }Which of the following line of code is suitable to start a thread ?,"Thread t = new Thread(X),","Thread t = new Thread(X), t.start(),","X run = new X(), Thread t = new Thread(run), t.start(),","Thread t = new Thread(), x.run(),", ,C, <p>Option C is suitable to start a thread.</p> 
Cse Engineering,Threads, ,Which cannot directly cause a thread to stop executing?,Calling the SetPriority() method on a Thread object.,Calling the wait() method on an object.,Calling notify() method on an object.,Calling read() method on an InputStream object., ,C," <p>Option C is correct. <i class=""java-code"">notify()</i> - wakes up a single thread that is waiting on this object's monitor.</p> "
Cse Engineering,Threads, ,Which two of the following methods are defined in class Thread?start()wait()notify()run()terminate(),1 and 4,2 and 3,3 and 4,2 and 4, ,A," <p>(1) and (4). Only <i class=""java-code"">start()</i> and <i class=""java-code"">run()</i> are defined by the <i class=""java-code"">Thread</i> class.</p><p>(2) and (3) are incorrect because they are methods of the <i class=""java-code"">Object</i> class. (5) is incorrect because there's no such method in any thread-related class.</p> "
Cse Engineering,Threads, ,Which three guarantee that a thread will leave the running state?yield()wait()notify()notifyAll()sleep(1000)aLiveThread.join()Thread.killThread(),"1, 2 and 4","2, 5 and 6","3, 4 and 7","4, 5 and 7", ,B," <p>(2) is correct because <i class=""java-code"">wait()</i> always causes the current thread to go into the object's wait pool. </p><p>(5) is correct because <i class=""java-code"">sleep()</i> will always pause the currently running thread for at least the duration specified in the sleep argument (unless an interrupted exception is thrown). </p><p>(6) is correct because, assuming that the thread you're calling <i class=""java-code"">join()</i> on is alive, the thread calling <i class=""java-code"">join()</i> will immediately block until the thread you're calling <i class=""java-code"">join()</i> on is no longer alive.</p><p>(1) is wrong, but tempting. The <i class=""java-code"">yield()</i> method is not guaranteed to cause a thread to leave the running state, although if there are runnable threads of the same priority as the currently running thread, then the current thread will probably leave the running state. </p><p>(3) and (4) are incorrect because they don't cause the thread invoking them to leave the running state.</p><p>(7) is wrong because there's no such method.</p> "
Cse Engineering,Threads, ,Which of the following will directly stop the execution of a Thread?,wait(),notify(),notifyall(),exits synchronized code, ,A," <p>Option A is correct. <i class=""java-code"">wait()</i> causes the current thread to wait until another thread invokes the <i class=""java-code"">notify()</i> method or the <i class=""java-code"">notifyAll()</i> method for this object.</p><p>Option B is wrong. <i class=""java-code"">notify()</i> - wakes up a single thread that is waiting on this object's monitor. </p><p>Option C is wrong. <i class=""java-code"">notifyAll()</i> - wakes up all threads that are waiting on this object's monitor.</p><p>Option D is wrong. Typically, releasing a lock means the thread holding the lock (in other words, the thread currently in the synchronized method) exits the synchronized method. At that point, the lock is free until some other thread enters a synchronized method on that object. Does entering/exiting synchronized code mean that the thread execution stops? Not necessarily because the thread can still run code that is not synchronized. I think the word directly in the question gives us a clue. Exiting synchronized code does not directly stop the execution of a thread.</p> "
Cse Engineering,Threads, ,Which method must be defined by a class implementing the java.lang.Runnable interface?,void run(),public void run(),public void start(),void run(int priority), ,B," <p>Option B is correct because in an interface all methods are abstract by default therefore they must be overridden by the implementing class. The <i class=""java-code"">Runnable</i> interface only contains 1 method, the <i class=""java-code"">void run()</i> method therefore it must be implemented. </p><p>Option A and D are incorrect because they are narrowing the access privileges i.e. package(default) access is narrower than public access. </p><p>Option C is not method in the <i class=""java-code"">Runnable</i> interface therefore it is incorrect. </p> "
Cse Engineering,Threads, ,Which will contain the body of the thread?,"run(),","start(),","stop(),","main(),", ,A," <p>Option A is Correct. The <i class=""java-code"">run()</i> method to a thread is like the <i class=""java-code"">main()</i> method to an application. Starting the thread causes the object's run method to be called in that separately executing thread.</p><p>Option B is wrong. The <i class=""java-code"">start()</i> method causes this thread to begin execution, the Java Virtual Machine calls the run method of this thread. </p><p>Option C is wrong. The <i class=""java-code"">stop()</i> method is deprecated. It forces the thread to stop executing. </p><p>Option D is wrong. Is the main entry point for an application.</p> "
Cse Engineering,Threads, ,Which method registers a thread in a thread scheduler?,"run(),","construct(),","start(),","register(),", ,C," <p>Option C is correct. The <i class=""java-code"">start()</i> method causes this thread to begin execution, the Java Virtual Machine calls the run method of this thread.</p><p>Option A is wrong. The <i class=""java-code"">run()</i> method of a thread is like the <i class=""java-code"">main()</i> method to an application. Starting the thread causes the object's run method to be called in that separately executing thread.</p><p>Option B is wrong. There is no <i class=""java-code"">construct()</i> method in the <i class=""java-code"">Thread</i> class.</p><p>Option D is wrong. There is no <i class=""java-code"">register()</i> method in the <i class=""java-code"">Thread</i> class.</p> "
Cse Engineering,Threads, ,"Assume the following method is properly synchronized and called from a thread A on an object B:wait(2000),After calling this method, when will the thread A become a candidate to get another turn at the CPU?","After thread A is notified, or after two seconds.","After the lock on B is released, or after two seconds.",Two seconds after thread A is notified.,Two seconds after lock B is released., ,A," <p>Option A. Either of the two events (notification or wait time expiration) will make the thread become a candidate for running again.</p><p>Option B is incorrect because a waiting thread will not return to runnable when the lock is released, unless a notification occurs.</p><p>Option C is incorrect because the thread will become a candidate immediately after notification, not two seconds afterwards. </p><p>Option D is also incorrect because a thread will not come out of a waiting pool just because a lock has been released.</p> "
Cse Engineering,Threads, ,Which of the following will not directly cause a thread to stop?,notify(),wait(),InputStream access,sleep(), ,A," <p>Option A is correct. <i class=""java-code"">notify()</i> - wakes up a single thread that is waiting on this object's monitor.</p><p>Option B is wrong. <i class=""java-code"">wait()</i> causes the current thread to wait until another thread invokes the <i class=""java-code"">notify()</i> method or the <i class=""java-code"">notifyAll()</i> method for this object. </p><p>Option C is wrong. Methods of the InputStream class block until input data is available, the end of the stream is detected, or an exception is thrown. Blocking means that a thread may stop until certain conditions are met.</p><p>Option D is wrong. <i class=""java-code"">sleep()</i> - Causes the currently executing thread to sleep (temporarily cease execution) for a specified number of milliseconds. The thread does not lose ownership of any monitors.</p> "
Cse Engineering,Threads, ,"Which class or interface defines the wait(), notify(),and notifyAll() methods?",Object,Thread,Runnable,Class, ,A," <p>The <i class=""java-code"">Object</i> class defines these thread-specific methods.</p><p>Option B, C, and D are incorrect because they do not define these methods. And yes, the Java API does define a class called <i class=""java-code"">Class</i>, though you do not need to know it for the exam.</p> "
Cse Engineering,Threads, ,public class MyRunnable implements Runnable {    public void run()     {        // some code here    }}which of these will create and start this thread?,"new Runnable(MyRunnable).start(),","new Thread(MyRunnable).run(),","new Thread(new MyRunnable()).start(),","new MyRunnable().start(),", ,C," <p>Because the class implements <i class=""java-code"">Runnable</i>, an instance of it has to be passed to the <i class=""java-code"">Thread</i> constructor, and then the instance of the <i class=""java-code"">Thread</i> has to be started.</p><p>A is incorrect. There is no constructor like this for <i class=""java-code"">Runnable</i> because <i class=""java-code"">Runnable</i> is an interface, and it is illegal to pass a class or interface name to any constructor.</p><p>B is incorrect for the same reason, you can't pass a class or interface name to any constructor.</p><p>D is incorrect because <i class=""java-code"">MyRunnable</i> doesn't have a <i class=""java-code"">start()</i> method, and the only <i class=""java-code"">start()</i> method that can start a thread of execution is the <i class=""java-code"">start()</i> in the <i class=""java-code"">Thread</i> class.</p> "
Cse Engineering,Assertions, ,"What will be the output of the program?public class Test {      public static void main(String[] args)     {         int x = 0,          assert (x > 0) ? ""assertion failed"" : ""assertion passed"" ,         System.out.println(""finished""),      } }",finished,Compiliation fails.,An AssertionError is thrown and finished is output.,"An AssertionError is thrown with the message ""assertion failed.""", ,B, <p>Compilation Fails. You can't use the Assert statement in a similar way to the ternary operator. Don't confuse.</p> 
Cse Engineering,Assertions, ,"public class Test {     public void foo()     {        assert false, /* Line 5 */        assert false, /* Line 6 */    }     public void bar()    {        while(true)        {            assert false, /* Line 12 */        }         assert false,  /* Line 14 */    } }What causes compilation to fail?",Line 5,Line 6,Line 12,Line 14, ,D," <p>Option D is correct. Compilation fails because of an unreachable statement at line 14. It is a compile-time error if a statement cannot be executed because it is unreachable. The question is now, why is line 20 unreachable? If it is because of the assert then surely line 6 would also be unreachable. The answer must be something other than assert. </p><p>Examine the following: </p><p>A while statement can complete normally if and only if at least one of the following is true: </p><p>- The <i class=""java-code"">while</i> statement is reachable and the condition expression is not a constant expression with value true.</p><p>-There is a reachable break statement that exits the <i class=""java-code"">while</i> statement. </p><p>The while statement at line 11 is infinite and there is no break statement therefore line 14 is unreachable. You can test this with the following code:</p><pre class=""code-pre""><code class=""java""><span class=""keyword"">public</span> <span class=""class""><span class=""keyword"">class</span> <span class=""title"">Test80</span> {</span>     <span class=""keyword"">public</span> <span class=""keyword"">void</span> foo()     {        <span class=""keyword"">assert</span> <span class=""keyword"">false</span>,         <span class=""keyword"">assert</span> <span class=""keyword"">false</span>,     }     <span class=""keyword"">public</span> <span class=""keyword"">void</span> bar()    {        <span class=""keyword"">while</span>(<span class=""keyword"">true</span>)        {            <span class=""keyword"">assert</span> <span class=""keyword"">false</span>,             <span class=""keyword"">break</span>,         }         <span class=""keyword"">assert</span> <span class=""keyword"">false</span>,      } }</code></pre><p></p> "
Cse Engineering,Assertions, ,"What will be the output of the program?public class Test {    public static int y,    public static void foo(int x)     {        System.out.print(""foo ""),        y = x,    }    public static int bar(int z)     {        System.out.print(""bar ""),        return y = z,    }    public static void main(String [] args )     {        int t = 0,        assert t > 0 : bar(7),        assert t > 1 : foo(8), /* Line 18 */        System.out.println(""done ""),    }}",bar,bar done,foo done,Compilation fails, ,D," <p>The <i class=""java-code"">foo()</i> method returns void. It is a perfectly acceptable method, but because it returns void it cannot be used in an <i class=""java-code"">assert</i> statement, so line 18 will not compile.</p> "
Cse Engineering,Assertions, ,"What will be the output of the program (when you run with the -ea option) ?public class Test {      public static void main(String[] args)     {        int x = 0,          assert (x > 0) : ""assertion failed"", /* Line 6 */        System.out.println(""finished""),     } }",finished,Compilation fails.,An AssertionError is thrown.,An AssertionError is thrown and finished is output., ,C," <p>An assertion Error is thrown as normal giving the output ""assertion failed"". The word ""finished"" is not printed (ensure you run with the <i class=""java-code"">-ea</i> option)</p><p>Assertion failures are generally labeled in the stack trace with the file and line number from which they were thrown, and also in this case with the error's detail message  ""assertion failed"". The detail message is supplied by the assert statement in line 6.</p> "
Cse Engineering,Assertions, ,"public class Test2 {    public static int x,    public static int foo(int y)     {        return y * 2,    }    public static void main(String [] args)     {        int z = 5,        assert z > 0, /* Line 11 */        assert z > 2: foo(z), /* Line 12 */        if ( z < 7 )            assert z > 4, /* Line 14 */        switch (z)         {            case 4: System.out.println(""4 ""),            case 5: System.out.println(""5 ""),            default: assert z < 10,        }        if ( z < 10 )            assert z > 4: z++, /* Line 22 */        System.out.println(z),    }}which line is an example of an inappropriate use of assertions?",Line 11,Line 12,Line 14,Line 22, ,D," <p>Assert statements should not cause side effects. Line 22 changes the value of <i class=""java-code"">z</i> if the assert statement is <i class=""java-code"">false</i>.</p><p>Option A is fine, a second expression in an assert statement is not required. </p><p>Option B is fine because it is perfectly acceptable to call a method with the second expression of an assert statement. </p><p>Option C is fine because it is proper to call an assert statement conditionally.</p> "
